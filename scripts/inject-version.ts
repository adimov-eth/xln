#!/usr/bin/env bun
/**
 * Inject git version info at build time
 * Auto-runs before dev/build to keep version fresh
 */

import { execSync } from 'child_process';
import { writeFileSync, mkdirSync } from 'fs';
import { dirname } from 'path';

try {
  const gitHash = execSync('git rev-parse HEAD').toString().trim();
  const gitShort = execSync('git rev-parse --short HEAD').toString().trim();
  const gitMessage = execSync('git log -1 --pretty=%B').toString().trim();
  const gitDate = execSync('git log -1 --format=%cd --date=iso').toString().trim();
  const gitBranch = execSync('git rev-parse --abbrev-ref HEAD').toString().trim();

  const version = {
    hash: gitHash,
    short: gitShort,
    message: gitMessage,
    date: gitDate,
    branch: gitBranch,
    buildTime: new Date().toISOString(),
    githubUrl: `https://github.com/xlnfinance/xln/commit/${gitHash}`
  };

  const outputPath = 'frontend/src/lib/generated/version.ts';
  mkdirSync(dirname(outputPath), { recursive: true });

  writeFileSync(
    outputPath,
    `// Auto-generated by scripts/inject-version.ts - DO NOT EDIT
export const VERSION = ${JSON.stringify(version, null, 2)} as const;
`
  );

  console.log(`[OK] Version info injected: ${gitShort} - ${gitMessage.split('\n')[0].slice(0, 50)}`);
} catch (error) {
  console.error('[X] Failed to inject version:', error);
  // Create fallback version to prevent build failures
  const fallback = {
    hash: 'unknown',
    short: 'dev',
    message: 'Development build',
    date: new Date().toISOString(),
    branch: 'unknown',
    buildTime: new Date().toISOString(),
    githubUrl: 'https://github.com/xlnfinance/xln'
  };

  const outputPath = 'frontend/src/lib/generated/version.ts';
  mkdirSync(dirname(outputPath), { recursive: true });
  writeFileSync(
    outputPath,
    `// Fallback version (git not available)
export const VERSION = ${JSON.stringify(fallback, null, 2)} as const;
`
  );
}
