# XLN Scheme Reimplementation Plan
# Target: Racket - Feature-complete - Fresh redesign

## [STATS] Current Status (2025-10-26)

**Phase 1: Foundation** - [OK] 100% COMPLETE ✅
- [OK] types.rkt: State machines, domain types, RCPAN invariant
- [OK] crypto.rkt: SHA256 hashing (built-in, no FFI)
- [OK] rlp.rkt: Ethereum-compatible encoding/decoding
- [OK] merkle.rkt: Merkle trees with proofs

**Phase 2: Consensus Machines** - [OK] 100% COMPLETE ✅
- [OK] consensus/account/machine.rkt: Bilateral (2-of-2) consensus
- [OK] consensus/entity/machine.rkt: BFT (≥2/3 quorum) consensus
- [OK] Byzantine tolerance: Tolerates f = (n-1)/3 failures
- [OK] All demos passing: bilateral + BFT + Byzantine failure

**Latest Commit:** `d11935d - feat: add BFT entity consensus (Phase 2 complete)`

**Run All Demos:**
```bash
cd rework/xln-scheme

# Phase 1: Foundation
racket examples/basic-channel.rkt  # State machine demo
racket examples/crypto-demo.rkt    # SHA256 + frame hashing
racket examples/rlp-demo.rkt       # RLP encoding + Ethereum vectors
racket examples/merkle-demo.rkt    # Merkle trees + A-root

# Phase 2: Consensus
racket examples/bilateral-consensus-demo.rkt  # 2-of-2 consensus
racket examples/bft-consensus-demo.rkt        # BFT with 3 validators
racket examples/byzantine-failure-demo.rkt    # Byzantine tolerance proof
```

---

## Core Principles

1. **Homoiconic**: State machines as data structures
2. **Coinductive**: Infinite streams, not discrete ticks
3. **Effect boundary**: Pure consensus core, impure shell
4. **Sound by construction**: Dependent types prove RCPAN
5. **Macro-generated**: DSL for consensus machines + verification

---

## Phase 1: Foundation (Week 1-2) [OK] COMPLETE ✅

### Core Abstractions
```
xln-scheme/core/
├── types.rkt           [OK] DONE - Record types, state machine definitions
├── crypto.rkt          [OK] DONE - SHA256 hashing (built-in Racket, no FFI)
├── rlp.rkt             [OK] DONE - Ethereum-compatible serialization
├── merkle.rkt          [OK] DONE - Merkle tree + proof verification
└── monad.rkt           [SKIP] Not needed for MVP - direct IO is fine
```

### Completed [OK]
- [x] **State machine macro**: `(define-machine name states transitions)` - WORKING
- [x] **Domain types**: entity-id, account-key, delta, frame - WORKING
- [x] **RCPAN invariant**: Enforced at construction time - PROVEN
- [x] **Pattern matching**: Transition functions using match - WORKING
- [x] **Perspective calculations**: derive-capacity for left/right view - WORKING
- [x] **Working demo**: `examples/basic-channel.rkt` runs successfully
- [x] **SHA256 hashing**: Built-in `sha256-bytes` from `file/sha1` module
- [x] **RLP encoding**: Bytes, integers, lists + round-trip decode
- [x] **Merkle trees**: Root computation, proof generation/verification
- [x] **All test vectors**: Ethereum RLP vectors match exactly

**Status:** Phase 1 foundation COMPLETE. All primitives proven working:

**Crypto primitives:**
- SHA256 hashing (deterministic, no FFI)
- Frame hashing (S-expressions → bytes → hash)
- Channel key derivation (canonical ordering)

**Serialization:**
- RLP encode/decode (bytes, integers, lists)
- Ethereum test vectors verified
- Nested list support

**Merkle trees:**
- Root computation (even/odd leaves)
- Proof generation (sibling path)
- Proof verification (tamper-proof)
- A-root commitment (account state)

**Run demos:**
```bash
cd rework/xln-scheme
racket examples/basic-channel.rkt  # State machine
racket examples/crypto-demo.rkt    # Hashing
racket examples/rlp-demo.rkt       # Serialization
racket examples/merkle-demo.rkt    # Merkle trees
```

**Key Innovation Achieved:**
- State machines ARE S-expressions (introspectable, composable, verifiable)
- No external dependencies for crypto (uses built-in Racket functions)
- All encoding deterministic (same input → same output always)

**Next:** Phase 2 - Consensus machines (bilateral + BFT)

---

## Phase 2: Consensus Machines (Week 3-4) [OK] COMPLETE ✅

### Bilateral Consensus (Account Layer) [OK] DONE
```
xln-scheme/consensus/account/
├── machine.rkt         [OK] DONE - Bilateral state machine (296 lines)
├── handlers.rkt        [FUTURE] Transaction handlers (payment, credit-limit, etc)
├── delta.rkt           [FUTURE] Perspective-aware delta calculations
└── verification.rkt    [FUTURE] RCPAN invariant checking
```

**Implemented State Machine:**
```racket
(struct account-machine (entity-id counterparty-id height mempool
                         pending-frame current-frame deltas counter
                         sent-transitions) #:mutable #:transparent)

;; Flow: propose-frame → handle-account-input (ACK) → commit
;; - Counter-based replay protection ✓
;; - prevFrameHash chain linkage ✓
;; - Simultaneous proposal resolution (left wins) ✓
```

**Completed Deliverables:**
- [x] **Bilateral state machine** (296 lines) - WORKING
- [x] **Frame signing (2-of-2 required)** - Both parties must sign
- [x] **Counter mechanism (replay protection)** - Sequential counters prevent replay
- [x] **Chain linkage (prevFrameHash)** - Prevents forks
- [x] **Simultaneous proposals** - Left entity wins (deterministic tiebreaker)
- [x] **Demo passing** - bilateral-consensus-demo.rkt runs successfully
- [ ] Transaction handlers (payment, add-delta, set-credit-limit) - FUTURE
- [ ] Delta derivation with left/right perspective - FUTURE
- [ ] RCPAN type refinement (compile-time proof) - FUTURE

### BFT Consensus (Entity Layer) [OK] DONE
```
xln-scheme/consensus/entity/
├── machine.rkt         [OK] DONE - BFT state machine (371 lines)
├── proposer.rkt        [INTEGRATED] Proposer logic in machine.rkt
├── quorum.rkt          [INTEGRATED] Quorum calculation in machine.rkt
└── validation.rkt      [FUTURE] Frame verification
```

**Implemented State Machine:**
```racket
(struct entity-replica (entity-id signer-id state mempool
                        proposal locked-frame is-proposer) #:mutable #:transparent)

;; Flow: Non-proposer forwards → Proposer proposes → Validators lock & precommit → Commit
;; - Proposer-based mode (validators send precommits to proposer) ✓
;; - CometBFT-style locking (prevents double-signing) ✓
;; - Shares-based quorum (≥2/3 threshold) ✓
```

**Completed Deliverables:**
- [x] **BFT state machine** (371 lines) - WORKING
- [x] **PROPOSE → PRECOMMIT → COMMIT flow** - Complete BFT cycle
- [x] **Quorum threshold verification (≥2/3)** - Shares-based voting power
- [x] **CometBFT locking** - Validators lock before precommit
- [x] **Byzantine tolerance** - Tolerates f = (n-1)/3 failures
- [x] **Byzantine scenario tests** - byzantine-failure-demo.rkt proves tolerance
- [x] **BFT demo passing** - bft-consensus-demo.rkt (3 validators)
- [ ] Deterministic transaction ordering (nonce → from → kind) - FUTURE
- [ ] A-root Merkle commitment - FUTURE

**Key Achievements:**
- ✅ Bilateral consensus: Alice proposes → Bob signs → Alice commits
- ✅ BFT consensus: Proposer creates frame → Validators sign → Quorum reached → Commit
- ✅ Byzantine tolerance: System works with 1/3 validators offline
- ✅ Quorum math: 3/3 pass, 2/3 pass (quorum!), 1/3 fails ✓

### Runtime Coordinator [NEXT]
```
xln-scheme/consensus/runtime.rkt  [FUTURE] - Phase 3
```

**Architecture:**
```scheme
;; NOT tick polling - continuous stream
(define inputs-stream
  (stream-append external-events internal-events))

(define states-stream
  (stream-scan transition initial-state inputs-stream))

;; R[RIGHTWARDS]E[RIGHTWARDS]A routing via pattern matching
(define (route-input input)
  (match input
    [`(server ,_) (handle-server input)]
    [`(entity ,id ,_) (handle-entity id input)]
    [`(account ,key ,_) (handle-account key input)]))
```

**Deliverables (Phase 3):**
- [ ] Stream-based coordinator (not 100ms ticks)
- [ ] R[RIGHTWARDS]E[RIGHTWARDS]A input routing
- [ ] Multi-replica simulation orchestration
- [ ] Snapshot creation (periodic + on-demand)
- [ ] Deterministic processing order

---

## Phase 3: Network Layer (Week 5)

### Gossip Protocol
```
xln-scheme/network/
├── gossip.rkt          # CRDT lattice for profiles
├── discovery.rkt       # Capacity derivation from deltas
└── convergence.rkt     # Timestamp-based merge
```

**Key Insight:**
```scheme
;; Gossip = Lattice CRDT (automatic convergence)
(struct profile (entity-id timestamp capacities) #:transparent)

(define (lattice-merge p1 p2)
  (if (> (profile-timestamp p1) (profile-timestamp p2))
      p1
      p2))
```

**Deliverables:**
- [ ] Profile announcement
- [ ] Timestamp-based updates
- [ ] Capacity calculation: `deriveDelta(delta, isLeft) [RIGHTWARDS] {in, out}`
- [ ] Convergence tests

### Routing System
```
xln-scheme/routing/
├── graph.rkt           # Network topology from gossip
├── pathfinding.rkt     # Modified Dijkstra
└── fees.rkt            # Backwards fee calculation
```

**Deliverables:**
- [ ] Network graph construction
- [ ] PathFinder: Dijkstra with capacity constraints
- [ ] Multi-route support (up to 100 routes)
- [ ] Fee calculation (backwards from target to source)

---

## Phase 4: Blockchain Integration (Week 6)

### Smart Contract FFI
```
xln-scheme/blockchain/
├── contracts.rkt       # ABIs (EntityProvider, Depository, SubcontractProvider)
├── evm.rkt             # Web3 FFI or JSON-RPC
├── batch.rkt           # Batch operation encoding
└── events.rkt          # Event log watching
```

**Deliverables:**
- [ ] Contract ABI loading
- [ ] EVM connection (local/remote)
- [ ] processBatch encoding
- [ ] Event watching (ReserveUpdated, SettlementProcessed)
- [ ] Integration tests with Hardhat/Anvil

---

## Phase 5: Persistence (Week 7)

### Write-Ahead Log + Snapshots
```
xln-scheme/storage/
├── wal.rkt             # Append-only log with CRC32
├── snapshot.rkt        # LZ4-compressed state snapshots
└── leveldb.rkt         # KV store bindings (or SQLite fallback)
```

**WAL Pattern:**
```scheme
(define (apply-with-wal change state)
  (do [_ <- (wal-append change)]
      [state' <- (pure (apply-change state change))]
      [_ <- (leveldb-batch-write state')]
      (pure state')))
```

**Deliverables:**
- [ ] WAL append with checksums
- [ ] Snapshot creation (periodic triggers)
- [ ] Recovery on restart
- [ ] Deterministic replay tests
- [ ] Crash recovery scenarios

---

## Phase 6: API & Frontend Integration (Week 8)

### WebSocket Server
```
xln-scheme/api/
├── websocket.rkt       # Live connection for frontend
├── rpc.rkt             # JSON-RPC handlers
└── scenarios.rkt       # World DSL execution
```

**Deliverables:**
- [ ] WebSocket server for state sync
- [ ] JSON-RPC endpoints
- [ ] Time machine support (historical queries)
- [ ] World scenario executor
- [ ] Frontend integration tests

---

## Design Improvements Over TypeScript

### 1. Homoiconic State Machines
```scheme
;; State machine IS data - can be queried, composed, verified
(define bilateral-machine
  '(machine
    (states idle pending finalized)
    (transitions
      ((idle × propose) [RIGHTWARDS] pending)
      ((pending × sign) [RIGHTWARDS] finalized))))

;; Generate verification conditions automatically
(verify-liveness bilateral-machine)   ;; Proves no deadlocks
(verify-safety bilateral-machine)      ;; Proves invariants hold
```

### 2. Effect System (Pure Core)
```scheme
;; Consensus logic is PURE - no hidden state
(define/contract (bilateral-transition state input)
  (-> State? Input? (Free XLN-Effects (cons State? (listof Output?))))
  ...)

;; Effects handled at boundary
(run-with-io (bilateral-transition state input))
```

### 3. Dependent Types (RCPAN Proven)
```scheme
(define-type Delta
  (Refine [δ : Integer]
          [L_left : Natural]
          [L_right : Natural]
          [C : Natural]
          (and (<= (- L_left) δ)
               (<= δ (+ C L_right)))))

;; Invalid deltas rejected at COMPILE TIME
```

### 4. Stream-Based (Not Tick Polling)
```scheme
;; Coinductive - infinite stream
(define states-stream
  (stream-scan transition initial-state inputs-stream))

;; Observe forever
(stream-for-each handle-snapshot states-stream)
```

### 5. Pattern Matching (No If-Else Spaghetti)
```scheme
(match (cons state input)
  [`((idle ,_) . (propose-frame ,frame))
   (pending frame)]

  [`((pending ,frame) . (countersign ,sig))
   #:when (verify-signature? sig frame)
   (finalized (increment-counter state) frame)]

  [_ (error "Invalid transition")])
```

### 6. Macro DSL
```scheme
(define-consensus bilateral
  #:states [idle pending finalized]
  #:invariant valid-counter?

  (transition propose
    [idle [RIGHTWARDS] pending]
    #:when valid-signature?
    #:update set-frame
    #:emit broadcast-to-counterparty))

;; Macro generates:
;; - State machine code
;; - Property tests
;; - Verification conditions
;; - API endpoints
```

---

## Success Criteria

- [ ] **Determinism**: Replay from genesis produces identical state
- [ ] **Byzantine tolerance**: ≥2/3 quorum required, tolerates f < n/3 faults
- [ ] **Performance**: Process 100 entities with <100ms latency
- [ ] **Soundness**: RCPAN invariant proven at compile time
- [ ] **Emergence**: Routing converges without coordination
- [ ] **Frontend parity**: Visualizes network, time machine works
- [ ] **World scenarios**: Execute diamond-dybvig, phantom-grid identically

---

## Directory Structure

```
xln-scheme/
├── core/               # Primitives (crypto, RLP, merkle, monads)
├── consensus/
│   ├── account/        # Bilateral state machine
│   ├── entity/         # BFT state machine
│   └── runtime.rkt     # Coordinator
├── network/
│   ├── gossip.rkt      # CRDT lattice
│   └── routing/        # Graph, pathfinding
├── blockchain/
│   ├── contracts.rkt   # ABIs
│   └── evm.rkt         # Web3 FFI
├── storage/
│   ├── wal.rkt         # Write-ahead log
│   ├── snapshot.rkt    # State snapshots
│   └── leveldb.rkt     # KV store
├── api/
│   ├── websocket.rkt   # Live connection
│   ├── rpc.rkt         # JSON-RPC
│   └── scenarios.rkt   # World DSL
├── tests/
│   ├── unit/           # Pure function tests
│   ├── property/       # QuickCheck-style
│   └── integration/    # Full system tests
└── examples/           # Demo scenarios
```

---

## Development Approach

### Week-by-week focus:
1. **Foundation**: Get crypto + RLP + merkle working
2. **Consensus**: Bilateral + BFT state machines proven sound
3. **Network**: Gossip + routing convergence
4. **Blockchain**: EVM integration tested
5. **Persistence**: WAL + snapshots + recovery
6. **API**: Frontend connects, scenarios execute
7. **Polish**: Performance tuning, documentation
8. **Verification**: Formal proofs of key properties

### Testing strategy:
- **Unit**: Every pure function
- **Property**: Determinism, Byzantine scenarios, CRPAN invariants
- **Integration**: Full R[RIGHTWARDS]E[RIGHTWARDS]A flows, blockchain interactions
- **Chaos**: Random inputs, crash recovery, network partitions

### Documentation:
- Code comments in S-expression style
- Architecture diagrams as S-expressions
- Literate programming for key algorithms
- Migration guide from TypeScript

---

## Philosophy

**Code = Data = S-expressions**

The entire system is introspectable, composable, verifiable. State machines are data structures. Effects are values. Time is a stream. Gossip is a lattice.

Homoiconicity enables:
- **Introspection**: Query running system structure
- **Composition**: Combine state machines algebraically
- **Verification**: Generate proofs from definitions
- **Macros**: Extend language for domain

**Coinductive, not inductive**

Channels don't terminate. Streams unfold forever. The observation produces itself.

`OneHand (fun c => hear c)` - sound without clapper.

---

**Status**: Ready to implement.

**First commit**: Core types + crypto primitives.

λ.
