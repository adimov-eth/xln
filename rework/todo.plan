# XLN Scheme Reimplementation Plan
# Target: Racket - Feature-complete - Fresh redesign

## [STATS] Current Status (2025-10-26)

**Phase 1: Foundation** - [OK] 100% COMPLETE ✅
- [OK] types.rkt: State machines, domain types, RCPAN invariant
- [OK] crypto.rkt: SHA256 hashing (built-in, no FFI)
- [OK] rlp.rkt: Ethereum-compatible encoding/decoding
- [OK] merkle.rkt: Merkle trees with proofs

**Phase 2: Consensus Machines** - [OK] 100% COMPLETE ✅
- [OK] consensus/account/machine.rkt: Bilateral (2-of-2) consensus
- [OK] consensus/entity/machine.rkt: BFT (≥2/3 quorum) consensus
- [OK] Byzantine tolerance: Tolerates f = (n-1)/3 failures
- [OK] All demos passing: bilateral + BFT + Byzantine failure

**Phase 3: Network Layer** - [OK] 100% COMPLETE ✅
- [OK] network/server.rkt: Multi-replica coordinator (155 lines)
- [OK] network/gossip.rkt: CRDT profile propagation (134 lines)
- [OK] network/routing.rkt: PathFinder with Dijkstra (295 lines)
- [OK] Multi-replica simulation: 5 validators, 10 frames, all synced
- [OK] Gossip + Routing: CRDT convergence + multi-hop pathfinding ✓
- [OK] Byzantine scenarios: 1-2 validators offline, still commits
- [OK] Safety verified: 3+ offline fails (below threshold)

**Phase 5: Persistence** - [OK] 100% COMPLETE ✅
- [OK] storage/wal.rkt: Write-ahead log with SHA256 checksums (161 lines)
- [OK] storage/snapshot.rkt: State snapshots with S-expression serialization (156 lines)
- [OK] Crash recovery demo: WAL logging → snapshot → crash → recovery → verify
- [OK] Deterministic replay: Snapshot at height 5 + WAL replay of 2 entries

**Latest Commit:** `4af2080 - feat: add persistence layer (Phase 5 complete)`

**Run All Demos (10 total):**
```bash
cd rework/xln-scheme

# Phase 1: Foundation (3 demos)
racket examples/crypto-demo.rkt    # SHA256 + frame hashing
racket examples/rlp-demo.rkt       # RLP encoding + Ethereum vectors
racket examples/merkle-demo.rkt    # Merkle trees + A-root

# Phase 2: Consensus (3 demos)
racket examples/bilateral-consensus-demo.rkt  # 2-of-2 consensus
racket examples/bft-consensus-demo.rkt        # BFT with 3 validators
racket examples/byzantine-failure-demo.rkt    # Byzantine tolerance proof

# Phase 3: Network Layer (3 demos)
racket examples/multi-replica-simulation.rkt  # 5 validators, 10 frames
racket examples/multi-replica-byzantine.rkt   # Byzantine tolerance (network)
racket examples/gossip-routing-demo.rkt       # Gossip CRDT + Dijkstra routing

# Phase 5: Persistence (1 demo)
racket examples/persistence-demo.rkt          # WAL + snapshots + crash recovery
```

---

## Core Principles

1. **Homoiconic**: State machines as data structures
2. **Coinductive**: Infinite streams, not discrete ticks
3. **Effect boundary**: Pure consensus core, impure shell
4. **Sound by construction**: Dependent types prove RCPAN
5. **Macro-generated**: DSL for consensus machines + verification

---

## Phase 1: Foundation (Week 1-2) [OK] COMPLETE ✅

### Core Abstractions
```
xln-scheme/core/
├── types.rkt           [OK] DONE - Record types, state machine definitions
├── crypto.rkt          [OK] DONE - SHA256 hashing (built-in Racket, no FFI)
├── rlp.rkt             [OK] DONE - Ethereum-compatible serialization
├── merkle.rkt          [OK] DONE - Merkle tree + proof verification
└── monad.rkt           [SKIP] Not needed for MVP - direct IO is fine
```

### Completed [OK]
- [x] **State machine macro**: `(define-machine name states transitions)` - WORKING
- [x] **Domain types**: entity-id, account-key, delta, frame - WORKING
- [x] **RCPAN invariant**: Enforced at construction time - PROVEN
- [x] **Pattern matching**: Transition functions using match - WORKING
- [x] **Perspective calculations**: derive-capacity for left/right view - WORKING
- [x] **Working demo**: `examples/basic-channel.rkt` runs successfully
- [x] **SHA256 hashing**: Built-in `sha256-bytes` from `file/sha1` module
- [x] **RLP encoding**: Bytes, integers, lists + round-trip decode
- [x] **Merkle trees**: Root computation, proof generation/verification
- [x] **All test vectors**: Ethereum RLP vectors match exactly

**Status:** Phase 1 foundation COMPLETE. All primitives proven working:

**Crypto primitives:**
- SHA256 hashing (deterministic, no FFI)
- Frame hashing (S-expressions → bytes → hash)
- Channel key derivation (canonical ordering)

**Serialization:**
- RLP encode/decode (bytes, integers, lists)
- Ethereum test vectors verified
- Nested list support

**Merkle trees:**
- Root computation (even/odd leaves)
- Proof generation (sibling path)
- Proof verification (tamper-proof)
- A-root commitment (account state)

**Run demos:**
```bash
cd rework/xln-scheme
racket examples/basic-channel.rkt  # State machine
racket examples/crypto-demo.rkt    # Hashing
racket examples/rlp-demo.rkt       # Serialization
racket examples/merkle-demo.rkt    # Merkle trees
```

**Key Innovation Achieved:**
- State machines ARE S-expressions (introspectable, composable, verifiable)
- No external dependencies for crypto (uses built-in Racket functions)
- All encoding deterministic (same input → same output always)

**Next:** Phase 2 - Consensus machines (bilateral + BFT)

---

## Phase 2: Consensus Machines (Week 3-4) [OK] COMPLETE ✅

### Bilateral Consensus (Account Layer) [OK] DONE
```
xln-scheme/consensus/account/
├── machine.rkt         [OK] DONE - Bilateral state machine (296 lines)
├── handlers.rkt        [FUTURE] Transaction handlers (payment, credit-limit, etc)
├── delta.rkt           [FUTURE] Perspective-aware delta calculations
└── verification.rkt    [FUTURE] RCPAN invariant checking
```

**Implemented State Machine:**
```racket
(struct account-machine (entity-id counterparty-id height mempool
                         pending-frame current-frame deltas counter
                         sent-transitions) #:mutable #:transparent)

;; Flow: propose-frame → handle-account-input (ACK) → commit
;; - Counter-based replay protection ✓
;; - prevFrameHash chain linkage ✓
;; - Simultaneous proposal resolution (left wins) ✓
```

**Completed Deliverables:**
- [x] **Bilateral state machine** (296 lines) - WORKING
- [x] **Frame signing (2-of-2 required)** - Both parties must sign
- [x] **Counter mechanism (replay protection)** - Sequential counters prevent replay
- [x] **Chain linkage (prevFrameHash)** - Prevents forks
- [x] **Simultaneous proposals** - Left entity wins (deterministic tiebreaker)
- [x] **Demo passing** - bilateral-consensus-demo.rkt runs successfully
- [ ] Transaction handlers (payment, add-delta, set-credit-limit) - FUTURE
- [ ] Delta derivation with left/right perspective - FUTURE
- [ ] RCPAN type refinement (compile-time proof) - FUTURE

### BFT Consensus (Entity Layer) [OK] DONE
```
xln-scheme/consensus/entity/
├── machine.rkt         [OK] DONE - BFT state machine (371 lines)
├── proposer.rkt        [INTEGRATED] Proposer logic in machine.rkt
├── quorum.rkt          [INTEGRATED] Quorum calculation in machine.rkt
└── validation.rkt      [FUTURE] Frame verification
```

**Implemented State Machine:**
```racket
(struct entity-replica (entity-id signer-id state mempool
                        proposal locked-frame is-proposer) #:mutable #:transparent)

;; Flow: Non-proposer forwards → Proposer proposes → Validators lock & precommit → Commit
;; - Proposer-based mode (validators send precommits to proposer) ✓
;; - CometBFT-style locking (prevents double-signing) ✓
;; - Shares-based quorum (≥2/3 threshold) ✓
```

**Completed Deliverables:**
- [x] **BFT state machine** (371 lines) - WORKING
- [x] **PROPOSE → PRECOMMIT → COMMIT flow** - Complete BFT cycle
- [x] **Quorum threshold verification (≥2/3)** - Shares-based voting power
- [x] **CometBFT locking** - Validators lock before precommit
- [x] **Byzantine tolerance** - Tolerates f = (n-1)/3 failures
- [x] **Byzantine scenario tests** - byzantine-failure-demo.rkt proves tolerance
- [x] **BFT demo passing** - bft-consensus-demo.rkt (3 validators)
- [ ] Deterministic transaction ordering (nonce → from → kind) - FUTURE
- [ ] A-root Merkle commitment - FUTURE

**Key Achievements:**
- ✅ Bilateral consensus: Alice proposes → Bob signs → Alice commits
- ✅ BFT consensus: Proposer creates frame → Validators sign → Quorum reached → Commit
- ✅ Byzantine tolerance: System works with 1/3 validators offline
- ✅ Quorum math: 3/3 pass, 2/3 pass (quorum!), 1/3 fails ✓

### Runtime Coordinator [NEXT]
```
xln-scheme/consensus/runtime.rkt  [FUTURE] - Phase 3
```

**Architecture:**
```scheme
;; NOT tick polling - continuous stream
(define inputs-stream
  (stream-append external-events internal-events))

(define states-stream
  (stream-scan transition initial-state inputs-stream))

;; R[RIGHTWARDS]E[RIGHTWARDS]A routing via pattern matching
(define (route-input input)
  (match input
    [`(server ,_) (handle-server input)]
    [`(entity ,id ,_) (handle-entity id input)]
    [`(account ,key ,_) (handle-account key input)]))
```

**Deliverables (Phase 3):**
- [ ] Stream-based coordinator (not 100ms ticks)
- [ ] R[RIGHTWARDS]E[RIGHTWARDS]A input routing
- [ ] Multi-replica simulation orchestration
- [ ] Snapshot creation (periodic + on-demand)
- [ ] Deterministic processing order

---

## Phase 3: Network Layer (Week 5) [OK] COMPLETE ✅

### Multi-Replica Coordinator [OK] DONE
```
xln-scheme/network/
└── server.rkt         [OK] DONE - Multi-replica coordinator (155 lines)
```

**Implemented Coordinator:**
```racket
(struct server-env (replicas height timestamp) #:mutable #:transparent)

(define (process-inputs env inputs timestamp)
  ;; Route inputs to replicas by "entityId:signerId" key
  ;; Apply consensus via handle-entity-input
  ;; Collect outputs for next iteration
  ...)
```

**Completed Deliverables:**
- [x] **Server environment** - Holds all replicas in hash table
- [x] **Input routing** - Routes by entityId:signerId key
- [x] **Message passing** - Coordinates validator communication
- [x] **Multi-replica simulation** - 5 validators, 10 frames ✓
- [x] **Byzantine tolerance** - 1-2 validators offline, still commits ✓
- [x] **Safety verified** - 3+ offline correctly fails ✓

### Gossip Protocol [OK] DONE
```
xln-scheme/network/
└── gossip.rkt         [OK] DONE - CRDT profile propagation (134 lines)
```

**Implemented CRDT Gossip:**
```racket
(struct profile (entity-id capabilities hubs metadata accounts timestamp))
(struct gossip-layer (profiles))  ; hash entity-id → profile

;; Last-write-wins CRDT semantics
(define (gossip-announce! layer prof)
  (when (> (profile-timestamp prof) (profile-timestamp existing))
    (hash-set! (gossip-layer-profiles layer) entity-id prof)))
```

**Completed Deliverables:**
- [x] **Profile announcement** - CRDT with timestamp-based convergence
- [x] **Capabilities advertising** - (listof string) e.g. ("router" "swap:memecoins")
- [x] **Fee configuration** - routing-fee-ppm, base-fee in metadata
- [x] **Account capacities** - in/out capacity per token for routing
- [x] **CRDT convergence** - Older updates ignored, newer updates win

### Routing System [OK] DONE
```
xln-scheme/network/
└── routing.rkt        [OK] DONE - PathFinder with Dijkstra (295 lines)
```

**Implemented PathFinder:**
```racket
(define (find-routes graph source target amount token-id [max-routes 100])
  ;; Modified Dijkstra with capacity constraints
  ;; Returns up to 100 routes sorted by total fee
  ...)

(define (calculate-fee edge amount)
  ;; Fee = baseFee + (amount * feePPM / 1,000,000)
  ...)
```

**Completed Deliverables:**
- [x] **Network graph construction** - Build from gossip profiles
- [x] **PathFinder algorithm** - Modified Dijkstra with capacity constraints
- [x] **Multi-route support** - Returns up to 100 routes sorted by fee
- [x] **Fee calculation** - baseFee + proportional (backwards accumulation)
- [x] **Success probability** - Exponential decay based on utilization
- [x] **Gossip + Routing demo** - End-to-end pathfinding demonstration

---

## Phase 4: Blockchain Integration (Week 6)

### Smart Contract FFI
```
xln-scheme/blockchain/
├── contracts.rkt       # ABIs (EntityProvider, Depository, SubcontractProvider)
├── evm.rkt             # Web3 FFI or JSON-RPC
├── batch.rkt           # Batch operation encoding
└── events.rkt          # Event log watching
```

**Deliverables:**
- [ ] Contract ABI loading
- [ ] EVM connection (local/remote)
- [ ] processBatch encoding
- [ ] Event watching (ReserveUpdated, SettlementProcessed)
- [ ] Integration tests with Hardhat/Anvil

---

## Phase 5: Persistence (Week 7)

### Write-Ahead Log + Snapshots
```
xln-scheme/storage/
├── wal.rkt             # Append-only log with CRC32
├── snapshot.rkt        # LZ4-compressed state snapshots
└── leveldb.rkt         # KV store bindings (or SQLite fallback)
```

**WAL Pattern:**
```scheme
(define (apply-with-wal change state)
  (do [_ <- (wal-append change)]
      [state' <- (pure (apply-change state change))]
      [_ <- (leveldb-batch-write state')]
      (pure state')))
```

**Deliverables:**
- [x] WAL append with checksums (SHA256)
- [x] Snapshot creation (on-demand)
- [x] Recovery on restart (snapshot + WAL replay)
- [x] Deterministic replay tests (height 5 → 8)
- [x] Crash recovery scenarios (persistence-demo.rkt)

---

## Phase 6: API & Frontend Integration (Week 8)

### WebSocket Server
```
xln-scheme/api/
├── websocket.rkt       # Live connection for frontend
├── rpc.rkt             # JSON-RPC handlers
└── scenarios.rkt       # World DSL execution
```

**Deliverables:**
- [ ] WebSocket server for state sync
- [ ] JSON-RPC endpoints
- [ ] Time machine support (historical queries)
- [ ] World scenario executor
- [ ] Frontend integration tests

---

## Design Improvements Over TypeScript

### 1. Homoiconic State Machines
```scheme
;; State machine IS data - can be queried, composed, verified
(define bilateral-machine
  '(machine
    (states idle pending finalized)
    (transitions
      ((idle × propose) [RIGHTWARDS] pending)
      ((pending × sign) [RIGHTWARDS] finalized))))

;; Generate verification conditions automatically
(verify-liveness bilateral-machine)   ;; Proves no deadlocks
(verify-safety bilateral-machine)      ;; Proves invariants hold
```

### 2. Effect System (Pure Core)
```scheme
;; Consensus logic is PURE - no hidden state
(define/contract (bilateral-transition state input)
  (-> State? Input? (Free XLN-Effects (cons State? (listof Output?))))
  ...)

;; Effects handled at boundary
(run-with-io (bilateral-transition state input))
```

### 3. Dependent Types (RCPAN Proven)
```scheme
(define-type Delta
  (Refine [δ : Integer]
          [L_left : Natural]
          [L_right : Natural]
          [C : Natural]
          (and (<= (- L_left) δ)
               (<= δ (+ C L_right)))))

;; Invalid deltas rejected at COMPILE TIME
```

### 4. Stream-Based (Not Tick Polling)
```scheme
;; Coinductive - infinite stream
(define states-stream
  (stream-scan transition initial-state inputs-stream))

;; Observe forever
(stream-for-each handle-snapshot states-stream)
```

### 5. Pattern Matching (No If-Else Spaghetti)
```scheme
(match (cons state input)
  [`((idle ,_) . (propose-frame ,frame))
   (pending frame)]

  [`((pending ,frame) . (countersign ,sig))
   #:when (verify-signature? sig frame)
   (finalized (increment-counter state) frame)]

  [_ (error "Invalid transition")])
```

### 6. Macro DSL
```scheme
(define-consensus bilateral
  #:states [idle pending finalized]
  #:invariant valid-counter?

  (transition propose
    [idle [RIGHTWARDS] pending]
    #:when valid-signature?
    #:update set-frame
    #:emit broadcast-to-counterparty))

;; Macro generates:
;; - State machine code
;; - Property tests
;; - Verification conditions
;; - API endpoints
```

---

## Success Criteria

- [ ] **Determinism**: Replay from genesis produces identical state
- [ ] **Byzantine tolerance**: ≥2/3 quorum required, tolerates f < n/3 faults
- [ ] **Performance**: Process 100 entities with <100ms latency
- [ ] **Soundness**: RCPAN invariant proven at compile time
- [ ] **Emergence**: Routing converges without coordination
- [ ] **Frontend parity**: Visualizes network, time machine works
- [ ] **World scenarios**: Execute diamond-dybvig, phantom-grid identically

---

## Directory Structure

```
xln-scheme/
├── core/               # Primitives (crypto, RLP, merkle, monads)
├── consensus/
│   ├── account/        # Bilateral state machine
│   ├── entity/         # BFT state machine
│   └── runtime.rkt     # Coordinator
├── network/
│   ├── gossip.rkt      # CRDT lattice
│   └── routing/        # Graph, pathfinding
├── blockchain/
│   ├── contracts.rkt   # ABIs
│   └── evm.rkt         # Web3 FFI
├── storage/
│   ├── wal.rkt         # Write-ahead log
│   ├── snapshot.rkt    # State snapshots
│   └── leveldb.rkt     # KV store
├── api/
│   ├── websocket.rkt   # Live connection
│   ├── rpc.rkt         # JSON-RPC
│   └── scenarios.rkt   # World DSL
├── tests/
│   ├── unit/           # Pure function tests
│   ├── property/       # QuickCheck-style
│   └── integration/    # Full system tests
└── examples/           # Demo scenarios
```

---

## Development Approach

### Week-by-week focus:
1. **Foundation**: Get crypto + RLP + merkle working
2. **Consensus**: Bilateral + BFT state machines proven sound
3. **Network**: Gossip + routing convergence
4. **Blockchain**: EVM integration tested
5. **Persistence**: WAL + snapshots + recovery
6. **API**: Frontend connects, scenarios execute
7. **Polish**: Performance tuning, documentation
8. **Verification**: Formal proofs of key properties

### Testing strategy:
- **Unit**: Every pure function
- **Property**: Determinism, Byzantine scenarios, CRPAN invariants
- **Integration**: Full R[RIGHTWARDS]E[RIGHTWARDS]A flows, blockchain interactions
- **Chaos**: Random inputs, crash recovery, network partitions

### Documentation:
- Code comments in S-expression style
- Architecture diagrams as S-expressions
- Literate programming for key algorithms
- Migration guide from TypeScript

---

## Philosophy

**Code = Data = S-expressions**

The entire system is introspectable, composable, verifiable. State machines are data structures. Effects are values. Time is a stream. Gossip is a lattice.

Homoiconicity enables:
- **Introspection**: Query running system structure
- **Composition**: Combine state machines algebraically
- **Verification**: Generate proofs from definitions
- **Macros**: Extend language for domain

**Coinductive, not inductive**

Channels don't terminate. Streams unfold forever. The observation produces itself.

`OneHand (fun c => hear c)` - sound without clapper.

---

**Status**: Ready to implement.

**First commit**: Core types + crypto primitives.

λ.
